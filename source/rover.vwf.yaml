---
extends: http://vwf.example.com/node3.vwf
properties:
  battery: 100
  batteryMax: 100
  ram: 100
  ramMax: 100
  boundaryMap:
    - [ -1, -1, -1, -1, -1, -1,  1,  1,  1, -1, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1, -1, -1, -1, -1,  1, -1, -1, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1,  1,  1,  1,  1,  1,  2,  2,  4, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1,  1, -1, -1, -1,  4, -1,  2, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1,  1, -1, -1, -1,  4, -1,  2, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1,  1,  1,  1, -1,  4, -1,  1, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1, -1, -1,  1, -1,  4, -1,  1, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1,  1,  1,  1,  1, -1,  2, -1,  1, -1, -1, -1, -1, -1, -1 ]
    - [ -1, -1, -1, -1, -1,  1, -1,  2, -1,  1,  1,  1,  1,  1, -1, -1 ]
    - [ -1, -1, -1,  1,  1,  1, -1,  2, -1,  1, -1, -1, -1,  1, -1, -1 ]
    - [ -1, -1, -1,  1, -1, -1, -1,  2, -1,  1, -1, -1, -1,  1,  1,  1 ]
    - [ -1, -1, -1,  1, -1, -1, -1,  2,  1,  1, -1, -1, -1,  1, -1, -1 ]
    - [  1,  2,  2,  1, -1, -1, -1,  2, -1, -1, -1, -1, -1,  2, -1, -1 ]
    - [  1, -1, -1,  1, -1, -1, -1,  2, -1, -1, -1, -1, -1,  2, -1, -1 ]
    - [  1, -1, -1,  1, -1, -1, -1,  2, -1, -1, -1, -1, -1,  2, -1, -1 ]
    - [ -1, -1, -1,  1,  1,  1,  1,  0, -1, -1, -1, -1, -1,  2, -1, -1 ]
  gridSquareLength: 3
  currentGridSquare: [ 0, 0 ]
  heading: 90
  terrainName: undefined
methods:
  moveForward:
  turnLeft:
  turnRight:
  translateOnTerrain:
scripts:
- |
  this.initialize = function() {
    // TODO: Find the first node of type boundaryMap.vwf and grab its map
    // TODO: Find current grid square (rather than making app developer specify)
    // TODO: Find the current heading (rather than making app developer specify)
  }

  this.moveForward = function() {
    var headingInRadians = this.heading * Math.PI / 180;
    var dirVector = [ Math.round( -Math.sin( headingInRadians ) ), Math.round( Math.cos( headingInRadians ) ) ];
    var proposedNewGridSquare = [ this.currentGridSquare[ 0 ] + dirVector[ 0 ], 
                                  this.currentGridSquare[ 1 ] + dirVector[ 1 ] ];
    var boundaryXArray = this.boundaryMap[ proposedNewGridSquare[ 0 ] ];
    if ( boundaryXArray ) {
      var boundaryValue = boundaryXArray[ proposedNewGridSquare[ 1 ] ];
      if ( ( boundaryValue < 0 ) || ( boundaryValue === undefined ) ) {
        this.logger.warnx( "moveForward", "Rover can't move forward" );
      } else {
        this.currentGridSquare = proposedNewGridSquare;
        // TODO: This should use worldTransformBy, but we are getting a bug where the rover's transform isn't set
        //       yet when this method is called.  Until we can debug that, we are assuming that the rover's 
        //       parent's frame of reference is the world frame of reference
        this.translateOnTerrain( [ dirVector[ 0 ] * this.gridSquareLength, 
                            dirVector[ 1 ] * this.gridSquareLength, 0 ], 1 );
        // this.worldTransformBy( [
        //   1, 0, 0, 0,  
        //   0, 1, 0, 0,  
        //   0, 0, 1, 0,  
        //   dirVector[ 0 ] * this.gridSquareLength, dirVector[ 1 ] * this.gridSquareLength, 0, 0 ], 1 );
      }
    }
  }

  this.turnLeft = function() {
    this.heading += 90;
    if ( this.heading > 360 ) {
      this.heading -= 360;
    }
    this.rotateBy( [ 0, 0, 1, 90 ], 1 );
  }

  this.turnRight = function() {
    this.heading -= 90;
    if ( this.heading < 0 ) {
      this.heading += 360;
    }
    this.rotateBy( [ 0, 0, 1, -90 ], 1 );
  } 

  this.translateOnTerrain = function( translation, duration ) {

    var terrain = this.find( "//" + this.terrainName )[0];
    var scene = this.find("/")[0];

    if ( terrain === undefined ) {

      this.translateBy( translation, duration );

    } else {

      var startTranslation = this.translation || goog.vec.Vec3.create();
      var deltaTranslation = this.translationFromValue( translation );
      var stopTranslation = goog.vec.Vec3.add(
        startTranslation,
        deltaTranslation,
        goog.vec.Vec3.create()
      );

      if(duration > 0) {

        this.animationDuration = duration;
        this.animationUpdate = function(time, duration) {

          var newTranslation = goog.vec.Vec3.lerp(
            startTranslation, stopTranslation,
            time >= duration ? 1 : time / duration,
            goog.vec.Vec3.create()
          );

          var origin = [ newTranslation[0], newTranslation[1], newTranslation[2] + 3 ];
          var intersects = scene.raycast( origin, [0,0,-1], 0, Infinity, true, terrain.id );
          newTranslation[2] = intersects.length > 0 ? intersects[0].point.z : newTranslation[2];

          this.translation = newTranslation;

        }

        this.animationPlay(0, duration);

      } else {

        this.translation = stopTranslation;

      }

    }

  }

  //@ sourceURL=source/rover.vwf