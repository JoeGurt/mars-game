---
extends: http://vwf.example.com/shaderMaterial.vwf
properties:
  lights: true
  diffuseMap:
    set: |
      this.uniforms.diffuseMap.value = this.newTexture( value );
      this.diffuseMap = value;
  normalMap:
    set: |
      this.uniforms.normalMap.value = this.newTexture( value );
      this.normalMap = value;
  specularMap:
    set: |
      this.uniforms.specularMap.value = this.newTexture( value );
      this.specularMap = value;
  diffuse:
    set: |
      this.uniforms.diffuse.value = this.newColor( value );
      this.diffuse = value;
    value: [ 255, 255, 255 ]
  ambient:
    set: |
      this.uniforms.ambient.value = this.newColor( value );
      this.ambient = value;
    value: [ 255, 255, 255 ]
  emissive:
    set: |
      this.uniforms.emissive.value = this.newColor( value );
      this.emissive = value;
    value: [ 0, 0, 0 ]
  specular:
    set: |
      this.uniforms.specular.value = this.newColor( value );
      this.specular = value;
    value: [ 255, 255, 255 ]
  normalScale:
    set: |
      this.uniforms.normalScale.value = new THREE.Vector2( value[ 0 ], value[ 1 ] );
      this.normalScale = value;
    value: [ 1, 1 ]
  opacity:
    set: |
      this.uniforms.opacity.value = value;
      this.opacity = value;
    value: 1
  shininess:
    set: |
      this.uniforms.shininess.value = Math.max( value, 1 );
      this.shininess = value;
    value: 30
  lightTrailHeight:
    set: |
      this.uniforms.lightTrailHeight.value = value;
      this.lightTrailHeight = value;
    value: 5
  updateFunction: |
    var time = Date.now() / 1000;
    if ( this.animating ) {
      this.elapsedTime += time - this.lastTickTime;
    }
    this.lastTickTime = time;
    if ( this.elapsedTime >= this.duration ) {
      this.elapsedTime = this.duration;
      this.animating = false;
    }
    var heightPct = this.elapsedTime / this.duration;
    var adjustedHeight = this.height + this.uniforms.lightTrailHeight.value;
    this.uniforms.ceiling.value = this.bottom + adjustedHeight * heightPct;
  elapsedTime: 0
  lastTickTime: 0
  duration: 5
  bottom: 0
  height: 1
  animating: false
  uniforms:
    ceiling:
      type: "f"
      value: 0
    lightTrailHeight:
      type: "f"
      value: 0
    diffuseMap:
      type: "t"
      value: 0
    normalMap:
      type: "t"
      value: 0
    specularMap:
      type: "t"
      value: 0
    diffuse:
      type: "c"
      value: 0
    ambient:
      type: "c"
      value: 0
    emissive:
      type: "c"
      value: 0
    specular:
      type: "c"
      value: 0
    normalScale:
      type: "v2"
      value: 0
    opacity:
      type: "f"
      value: 1
    shininess:
      type: "f"
      value: 30
    ambientLightColor:
      type: "fv"
      value: []
    directionalLightColor:
      type: "fv"
      value: []
    directionalLightDirection:
      type: "fv"
      value: []
    pointLightColor:
      type: "fv"
      value: []
    pointLightPosition:
      type: "fv"
      value: []
    pointLightDistance:
      type: "fv1"
      value: []
    spotLightColor:
      type: "fv"
      value: []
    spotLightPosition:
      type: "fv"
      value: []
    spotLightDistance:
      type: "fv1"
      value: []
    spotLightDirection:
      type: "fv"
      value: []
    spotLightAngleCos:
      type: "fv1"
      value: []
    spotLightExponent:
      type: "fv1"
      value: []
    hemisphereLightSkyColor:
      type: "fv"
      value: []
    hemisphereLightGroundColor:
      type: "fv"
      value: []
    hemisphereLightDirection:
      type: "fv1"
      value: []
    shadowMap:
      type: "tv"
      value: []
    shadowMapSize:
      type: "v2v"
      value: []
    shadowBias:
      type: "fv1"
      value: []
    shadowDarkness:
      type: "fv1"
      value: []
    shadowMatrix:
      type: "m4v"
      value: []
  vertexShader: |
    uniform float ceiling;
    uniform mat4 shadowMatrix[ MAX_SHADOWS ];
    varying vec4 vShadowCoord[ MAX_SHADOWS ];
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    varying vec3 vViewPosition;
    varying vec3 vNormal;
    void main() {
      vec3 objectNormal;
      objectNormal = normal;
      vec3 transformedNormal = normalMatrix * objectNormal;
      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vWorldPosition = worldPosition.xyz / worldPosition.w;
      for( int i = 0; i < MAX_SHADOWS; i ++ ) {
        vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;
      }
      vNormal = normalize( transformedNormal );
      vUv = uv;
      vec4 mvPosition = worldPosition;
      if ( mvPosition.z > ceiling ) {
        mvPosition.z = ceiling;
      }
      mvPosition = viewMatrix * mvPosition;
      vViewPosition = -mvPosition.xyz;
      gl_Position = projectionMatrix * mvPosition;
    }
  fragmentShader: |
    #extension GL_OES_standard_derivatives : enable
    uniform sampler2D diffuseMap;
    uniform sampler2D normalMap;
    uniform sampler2D specularMap;
    uniform vec3 diffuse;
    uniform float opacity;
    uniform vec3 ambient;
    uniform vec3 emissive;
    uniform vec3 specular;
    uniform float shininess;
    uniform vec2 normalScale;
    uniform vec3 ambientLightColor;
    uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];
    uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];
    uniform sampler2D shadowMap[ MAX_SHADOWS ];
    uniform vec2 shadowMapSize[ MAX_SHADOWS ];
    uniform float shadowDarkness[ MAX_SHADOWS ];
    uniform float shadowBias[ MAX_SHADOWS ];
    varying vec4 vShadowCoord[ MAX_SHADOWS ];
    uniform float ceiling;
    uniform float lightTrailHeight;
    varying vec2 vUv;
    varying vec3 vWorldPosition;
    varying vec3 vViewPosition;
    varying vec3 vNormal;
    vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapNormal ) {
      vec3 q0 = dFdx( eye_pos.xyz );
      vec3 q1 = dFdy( eye_pos.xyz );
      vec2 st0 = dFdx( vUv.st );
      vec2 st1 = dFdy( vUv.st );
      vec3 S = normalize( q0 * st1.t - q1 * st0.t );
      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
      vec3 N = normalize( surf_norm );
      vec3 mapN = mapNormal * 2.0 - 1.0;
      mapN.xy = normalScale * mapN.xy;
      mat3 tsn = mat3( S, T, N );
      return normalize( tsn * mapN );
    }
    float unpackDepth( const in vec4 rgba_depth ) {
      const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
      float depth = dot( rgba_depth, bit_shift );
      return depth;
    }
    void main() {
      gl_FragColor = texture2D( diffuseMap, vUv );
      float specularStrength = texture2D( specularMap, vUv ).r;
      vec3 normal = normalize( vNormal );
      vec3 viewPosition = normalize( vViewPosition );
      vec3 mapNormal = texture2D( normalMap, vUv ).rgb;
      normal = perturbNormal2Arb( -vViewPosition, normal, mapNormal );
      vec3 dirDiffuse = vec3( 0.0 );
      vec3 dirSpecular = vec3( 0.0 );
      for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {
        vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );
        vec3 dirVector = normalize( lDirection.xyz );
        float dotProduct = dot( normal, dirVector );
        float dirDiffuseWeight = max( dotProduct, 0.0 );
        dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;
        vec3 dirHalfVector = normalize( dirVector + viewPosition );
        float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );
        float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );
        float specularNormalization = ( shininess + 2.0 ) / 8.0;
        vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );
        dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;
      }
      vec3 totalDiffuse = vec3( 0.0 );
      vec3 totalSpecular = vec3( 0.0 );
      totalDiffuse += dirDiffuse;
      totalSpecular += dirSpecular;
      float fDepth;
      vec3 shadowColor = vec3( 1.0 );
      for( int i = 0; i < MAX_SHADOWS; i ++ ) {
        vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;
        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );
        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
        bool frustumTest = all( frustumTestVec );
        if ( frustumTest ) {
          shadowCoord.z += shadowBias[ i ];
          float shadow = 0.0;
          float xPixelOffset = 1.0 / shadowMapSize[ i ].x;
          float yPixelOffset = 1.0 / shadowMapSize[ i ].y;
          float dx0 = -1.0 * xPixelOffset;
          float dy0 = -1.0 * yPixelOffset;
          float dx1 = 1.0 * xPixelOffset;
          float dy1 = 1.0 * yPixelOffset;
          mat3 shadowKernel;
          mat3 depthKernel;
          depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );
          depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );
          depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );
          depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );
          depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );
          depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );
          depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );
          depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );
          depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );
          vec3 shadowZ = vec3( shadowCoord.z );
          shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));
          shadowKernel[0] *= vec3(0.25);
          shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));
          shadowKernel[1] *= vec3(0.25);
          shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));
          shadowKernel[2] *= vec3(0.25);
          vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );
          shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );
          shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );
          vec4 shadowValues;
          shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );
          shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );
          shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );
          shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );
          shadow = dot( shadowValues, vec4( 1.0 ) );
          shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );
        }
      }
      if ( shadowColor.r < 1.0 ) {
        totalSpecular = vec3( 0.0 );
      }
      gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;
      gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;
      float cBot = ceiling - lightTrailHeight;
      if ( vWorldPosition.z > cBot ) {
        float light = ( vWorldPosition.z - cBot ) / lightTrailHeight;
        gl_FragColor.rgb += vec3( light );
      }

    }
methods:
  newTexture:
    parameters:
      - value
    body: |
      var tex = THREE.ImageUtils.loadTexture( value );
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
  newColor:
    parameters:
      - value
    body: |
      var r, g, b, color;
      r = value[ 0 ] / 255;
      g = value[ 1 ] / 255;
      b = value[ 2 ] / 255;
      color = new THREE.Color( r, g, b );
      return color;
  animate: |
    this.elapsedTime = 0;
    this.animating = true;